"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createFileEmitter = exports.angular = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@babel/core");
const application_1 = require("@angular-devkit/build-angular/src/babel/presets/application");
const webpack_loader_1 = require("@angular-devkit/build-angular/src/babel/webpack-loader");
const ts = require("typescript");
const compiler_plugin_1 = require("@angular-devkit/build-angular/src/builders/browser-esbuild/compiler-plugin");
const load_esm_1 = require("@angular-devkit/build-angular/src/utils/load-esm");
const component_resolvers_1 = require("./component-resolvers");
function angular(pluginOptions = {
    tsconfig: process.env['NODE_ENV'] === 'test'
        ? './tsconfig.spec.json'
        : './tsconfig.app.json',
    workspaceRoot: process.cwd(),
}) {
    // The file emitter created during `onStart` that will be used during the build in `onLoad` callbacks for TS files
    let fileEmitter;
    let compilerOptions = {};
    // Temporary deep import for transformer support
    const { mergeTransformers, replaceBootstrap, } = require('@ngtools/webpack/src/ivy/transformation');
    const { augmentProgramWithVersioning, augmentHostWithCaching, } = require('@ngtools/webpack/src/ivy/host');
    const { SourceFileCache } = require('@ngtools/webpack/src/ivy/cache');
    let compilerCli;
    let rootNames;
    let host;
    let nextProgram;
    let builderProgram;
    let watchMode = false;
    let sourceFileCache = new SourceFileCache();
    let isProd = process.env['NODE_ENV'] === 'production';
    let isTest = process.env['NODE_ENV'] === 'test' || !!process.env['VITEST'];
    let viteServer;
    return [
        {
            name: '@analogjs/vite-plugin-angular',
            config(config, { command }) {
                return tslib_1.__awaiter(this, void 0, void 0, function* () {
                    watchMode = command === 'serve';
                    compilerCli = yield (0, load_esm_1.loadEsmModule)('@angular/compiler-cli');
                    return {
                        optimizeDeps: {
                            esbuildOptions: {
                                plugins: [
                                    (0, compiler_plugin_1.createCompilerPlugin)({
                                        tsconfig: pluginOptions.tsconfig,
                                        sourcemap: !isProd,
                                        advancedOptimizations: isProd,
                                    }, {
                                        workspaceRoot: pluginOptions.workspaceRoot,
                                        sourcemap: !isProd,
                                        optimization: isProd,
                                    }),
                                ],
                                define: {
                                    ngDevMode: watchMode ? JSON.stringify({}) : 'false',
                                    ngJitMode: 'false',
                                    ngI18nClosureMode: 'false',
                                },
                            },
                        },
                    };
                });
            },
            configureServer(server) {
                viteServer = server;
                server.watcher.on('add', setupCompilation);
                server.watcher.on('unlink', setupCompilation);
            },
            buildStart() {
                return tslib_1.__awaiter(this, void 0, void 0, function* () {
                    setupCompilation();
                    // Only store cache if in watch mode
                    if (watchMode) {
                        augmentHostWithCaching(host, sourceFileCache);
                    }
                    yield buildAndAnalyze();
                });
            },
            handleHotUpdate(ctx) {
                return tslib_1.__awaiter(this, void 0, void 0, function* () {
                    if (/\.[cm]?tsx?$/.test(ctx.file)) {
                        sourceFileCache.invalidate(ctx.file);
                        yield buildAndAnalyze();
                    }
                    if (/\.(html|htm|css|less|sass|scss)$/.test(ctx.file)) {
                        /**
                         * Check to see if this was a direct request
                         * for an external resource (styles, html).
                         */
                        const isDirect = ctx.modules.find((mod) => { var _a; return ctx.file === mod.file && ((_a = mod.id) === null || _a === void 0 ? void 0 : _a.includes('?direct')); });
                        if (isDirect) {
                            return ctx.modules;
                        }
                        let mods = [];
                        ctx.modules.forEach((mod) => {
                            mod.importers.forEach((imp) => {
                                sourceFileCache.invalidate(imp.id);
                                ctx.server.moduleGraph.invalidateModule(imp);
                                mods.push(imp);
                            });
                        });
                        yield buildAndAnalyze();
                        return mods;
                    }
                    return ctx.modules;
                });
            },
            transform(code, id) {
                var _a, _b;
                return tslib_1.__awaiter(this, void 0, void 0, function* () {
                    // Skip transforming node_modules
                    if (id.includes('node_modules')) {
                        return;
                    }
                    if (/\.[cm]?tsx?$/.test(id)) {
                        /**
                         * Re-analyze on each transform
                         * for test(Vitest)
                         */
                        if (isTest) {
                            const tsMod = viteServer.moduleGraph.getModuleById(id);
                            if (tsMod) {
                                sourceFileCache.invalidate(id);
                                yield buildAndAnalyze();
                            }
                        }
                        if (watchMode) {
                            if ((0, component_resolvers_1.hasTemplateUrl)(code)) {
                                const templateUrl = (0, component_resolvers_1.resolveTemplateUrl)(code, id);
                                if (templateUrl) {
                                    this.addWatchFile(templateUrl);
                                }
                            }
                            if ((0, component_resolvers_1.hasStyleUrls)(code)) {
                                const styleUrls = (0, component_resolvers_1.resolveStyleUrls)(code, id);
                                styleUrls.forEach((styleUrl) => {
                                    this.addWatchFile(styleUrl);
                                });
                            }
                        }
                        const typescriptResult = yield fileEmitter(id);
                        // return fileEmitter
                        const data = (_a = typescriptResult === null || typescriptResult === void 0 ? void 0 : typescriptResult.content) !== null && _a !== void 0 ? _a : '';
                        const forceAsyncTransformation = /for\s+await\s*\(|async\s+function\s*\*/.test(data);
                        const useInputSourcemap = (!isProd ? undefined : false);
                        if (!forceAsyncTransformation && !isProd) {
                            return {
                                code: isProd
                                    ? data.replace(/^\/\/# sourceMappingURL=[^\r\n]*/gm, '')
                                    : data,
                            };
                        }
                        const babelResult = yield (0, core_1.transformAsync)(data, {
                            filename: id,
                            inputSourceMap: (useInputSourcemap
                                ? undefined
                                : false),
                            sourceMaps: !isProd ? 'inline' : false,
                            compact: false,
                            configFile: false,
                            babelrc: false,
                            browserslistConfigFile: false,
                            plugins: [],
                            presets: [
                                [
                                    application_1.default,
                                    {
                                        forceAsyncTransformation,
                                        optimize: isProd && {},
                                    },
                                ],
                            ],
                        });
                        return {
                            code: (_b = babelResult === null || babelResult === void 0 ? void 0 : babelResult.code) !== null && _b !== void 0 ? _b : '',
                            map: babelResult === null || babelResult === void 0 ? void 0 : babelResult.map,
                        };
                    }
                    return undefined;
                });
            },
        },
        {
            name: '@analogjs/vite-plugin-angular-optimizer',
            apply: 'build',
            config() {
                return {
                    esbuild: {
                        legalComments: 'none',
                        keepNames: false,
                        define: isProd
                            ? {
                                ngDevMode: 'false',
                                ngJitMode: 'false',
                                ngI18nClosureMode: 'false',
                            }
                            : undefined,
                        supported: {
                            // Native async/await is not supported with Zone.js. Disabling support here will cause
                            // esbuild to downlevel async/await to a Zone.js supported form.
                            'async-await': false,
                            // Zone.js also does not support async generators or async iterators. However, esbuild does
                            // not currently support downleveling either of them. Instead babel is used within the JS/TS
                            // loader to perform the downlevel transformation. They are both disabled here to allow
                            // esbuild to handle them in the future if support is ever added.
                            // NOTE: If esbuild adds support in the future, the babel support for these can be disabled.
                            'async-generator': false,
                            'for-await': false,
                        },
                    },
                };
            },
            transform(code, id) {
                return tslib_1.__awaiter(this, void 0, void 0, function* () {
                    if (/\.[cm]?js$/.test(id)) {
                        const angularPackage = /[\\/]node_modules[\\/]@angular[\\/]/.test(id);
                        const linkerPluginCreator = (yield (0, load_esm_1.loadEsmModule)('@angular/compiler-cli/linker/babel')).createEs2015LinkerPlugin;
                        const forceAsyncTransformation = !/[\\/][_f]?esm2015[\\/]/.test(id) &&
                            /for\s+await\s*\(|async\s+function\s*\*/.test(code);
                        const shouldLink = yield (0, webpack_loader_1.requiresLinking)(id, code);
                        const useInputSourcemap = (!isProd ? undefined : false);
                        if (!forceAsyncTransformation && !isProd && !shouldLink) {
                            return {
                                code: isProd
                                    ? code.replace(/^\/\/# sourceMappingURL=[^\r\n]*/gm, '')
                                    : code,
                            };
                        }
                        const result = yield (0, core_1.transformAsync)(code, {
                            filename: id,
                            inputSourceMap: useInputSourcemap,
                            sourceMaps: !isProd ? 'inline' : false,
                            compact: false,
                            configFile: false,
                            babelrc: false,
                            browserslistConfigFile: false,
                            plugins: [],
                            presets: [
                                [
                                    application_1.default,
                                    {
                                        angularLinker: {
                                            shouldLink,
                                            jitMode: false,
                                            linkerPluginCreator,
                                        },
                                        forceAsyncTransformation,
                                        optimize: isProd && {
                                            looseEnums: angularPackage,
                                            pureTopLevel: angularPackage,
                                        },
                                    },
                                ],
                            ],
                        });
                        return {
                            code: (result === null || result === void 0 ? void 0 : result.code) || '',
                            map: result === null || result === void 0 ? void 0 : result.map,
                        };
                    }
                    return;
                });
            },
        },
    ];
    function setupCompilation() {
        const { options: tsCompilerOptions, rootNames: rn } = compilerCli.readConfiguration(pluginOptions.tsconfig, {
            enableIvy: true,
            noEmitOnError: false,
            suppressOutputPathCheck: true,
            outDir: undefined,
            inlineSources: !isProd,
            inlineSourceMap: !isProd,
            sourceMap: false,
            mapRoot: undefined,
            sourceRoot: undefined,
            declaration: false,
            declarationMap: false,
            allowEmptyCodegenFiles: false,
            annotationsAs: 'decorators',
            enableResourceInlining: false,
        });
        rootNames = rn;
        compilerOptions = tsCompilerOptions;
        host = ts.createIncrementalCompilerHost(compilerOptions);
    }
    /**
     * Creates a new NgtscProgram to analyze/re-analyze
     * the source files and create a file emitter.
     * This is shared between an initial build and a hot update.
     */
    function buildAndAnalyze() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create the Angular specific program that contains the Angular compiler
            const angularProgram = new compilerCli.NgtscProgram(rootNames, compilerOptions, host, nextProgram);
            const angularCompiler = angularProgram.compiler;
            const typeScriptProgram = angularProgram.getTsProgram();
            augmentProgramWithVersioning(typeScriptProgram);
            let builder;
            if (watchMode) {
                builder = builderProgram =
                    ts.createEmitAndSemanticDiagnosticsBuilderProgram(typeScriptProgram, host, builderProgram);
                nextProgram = angularProgram;
            }
            else {
                // When not in watch mode, the startup cost of the incremental analysis can be avoided by
                // using an abstract builder that only wraps a TypeScript program.
                builder = ts.createAbstractBuilder(typeScriptProgram, host);
            }
            yield angularCompiler.analyzeAsync();
            fileEmitter = createFileEmitter(builder, mergeTransformers(angularCompiler.prepareEmit().transformers, {
                before: [replaceBootstrap(() => builder.getProgram().getTypeChecker())],
            }), () => []);
        });
    }
}
exports.angular = angular;
function createFileEmitter(program, transformers = {}, onAfterEmit) {
    return (file) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        const sourceFile = program.getSourceFile(file);
        if (!sourceFile) {
            return undefined;
        }
        let content;
        program.emit(sourceFile, (filename, data) => {
            if (/\.[cm]?js$/.test(filename)) {
                content = data;
            }
        }, undefined /* cancellationToken */, undefined /* emitOnlyDtsFiles */, transformers);
        onAfterEmit === null || onAfterEmit === void 0 ? void 0 : onAfterEmit(sourceFile);
        return { content, dependencies: [] };
    });
}
exports.createFileEmitter = createFileEmitter;
//# sourceMappingURL=angular-vite-plugin.js.map